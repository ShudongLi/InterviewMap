# 闭包

闭包是 JavaScript 中最强大的抽象概念之一——但它也是最容易造成困惑的。它究竟是做什么的呢


下面是一个闭包结构
```
function makeAdder(a) {
  return function(b) {
    return a + b;
  }
}

let add5 = makeAdder(5);
let add20 = makeAdder(20);

add5(6); // 11
add20(7); // 27
```

上面的结构中，执行makeAdder，会返回其内部的函数。将其赋值给一个新的变量，继续执行，将会执行原makeAdder内部的方法，得到两次传入的参数的和。

# 解析

#### 发生了什么
一个函数被定义在了另外一个函数的内部，内部函数可以访问外部函数的变量。在例中，外部函数已经返回了，那么常识告诉我们局部变量“应该”不再存在。但是它们却仍然存在——否则 add 函数将不能工作。也就是说，这里存在 makeAdder 的局部变量的两个不同的“副本”——一个是 a 等于 5，另一个是 a 等于 20。那些函数的运行结果就和上面所说的一致。

#### 为什么发生
每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它使用一切被传入函数的变量进行初始化（初始化后，它包含一切被传入函数的变量）。这与那些保存的所有全局变量和函数的全局对象（global object）相类似，但仍有一些很重要的区别：
1. 1.每次函数被执行的时候，就会创建一个新的，特定的作用域对象；
2. 2.与全局对象（如浏览器的 window 对象）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前作用域对象中的属性的方法。

所以，当调用 makeAdder 时，解释器创建了一个作用域对象，它带有一个属性：a，这个属性被当作参数传入 makeAdder 函数。然后 makeAdder 返回一个新创建的函数（暂记为 adder）。通常，JavaScript 的垃圾回收器会在这时回收 makeAdder 创建的作用域对象（暂记为 b），但是，makeAdder 的返回值，新函数 adder，拥有一个指向作用域对象 b 的引用。最终，作用域对象 b 不会被垃圾回收器回收，直到没有任何引用指向新函数 adder。

#### 作用域链
作用域对象组成了一个名为作用域链（scope chain）的（调用）链。它和 JavaScript 的对象系统使用的原型（prototype）链相类似。

一个闭包，就是 一个函数 与其 被创建时所带有的作用域对象 的组合。闭包允许你保存状态——所以，它们可以用来代替对象。
